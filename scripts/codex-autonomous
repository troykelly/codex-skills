#!/usr/bin/env bash
#
# codex-autonomous - Start autonomous issue-driven development with Codex
#
# Usage:
#   codex-autonomous [OPTIONS]
#
# Options:
#   -e, --epic <N>       Focus on a specific epic/issue number (auto-continue prompts by default)
#   -n, --new            Bootstrap worktree, then prompt for instructions
#   -c, --continue       Resume the most recent autonomous session
#   --resume [ID]        Resume a session (worktree id or Codex session UUID). If omitted, shows list
#   -l, --list           List autonomous session history
#   -r, --repo <path>    Repository path (default: current directory)
#   -v, --version        Show version information
#   -h, --help           Show this help message
#
# Environment Variables:
#   WORK_EPIC                        Same as --epic
#   GITHUB_PERSONAL_ACCESS_TOKEN     GitHub token for MCP GitHub server (auto-fetched from gh if not set)
#   GITHUB_TOKEN                     Also exported for compatibility (derived from gh if missing)
#   MAX_CRASHES                      Maximum crashes before giving up (default: 10)
#   CODEX_AUTONOMOUS_FLAGS           Extra flags passed to Codex CLI (default: --dangerously-bypass-approvals-and-sandbox)
#   CODEX_AUTONOMOUS_MAX_SWITCHES    Max account switches per session (default: 10)
#   CODEX_ACCOUNT_COOLDOWN_MINUTES   Cooldown after account exhaustion (default: 5)
#   CODEX_DISABLE_HOOKS             Disable hook runner integration (default: false)
#   CODEX_NEW_PROMPT                 Initial prompt for --new (skips interactive prompt)
#   CODEX_AUTONOMOUS_INTERACTIVE     Prompt for user replies when Codex requests input (default: true)
#   CODEX_AUTONOMOUS_CONTINUE_PROMPT Default message when continuing without a user reply (default: "Continue autonomously.")
#   CODEX_AUTONOMOUS_SCHEMA_FILE     JSON schema file for structured agent responses
#   CODEX_HOOK_RUNNER               Path to codex-hook-runner (default: scripts/codex-hook-runner or PATH)
#   CODEX_HOOK_ROOT                  Hook root directory (default: $CODEX_HOME/hooks)
#   CODEX_HOOK_CONFIG                Path to hooks.json (default: $CODEX_HOOK_ROOT/hooks.json)
#   CODEX_HOOK_PROMPT_MODE           codex|print|skip (default: codex)
#   CODEX_HOME                       Codex home directory (default: ~/.codex)
#

set -euo pipefail

VERSION="1.0.0"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

CODEX_HOME="${CODEX_HOME:-${HOME}/.codex}"
HISTORY_FILE="${CODEX_HOME}/history.jsonl"
SESSIONS_DIR="${CODEX_HOME}/sessions"

SESSION_LOG="/tmp/codex-sessions.txt"
WORKTREE_ROOT="/tmp/codex-worktrees"

MAX_CRASHES="${MAX_CRASHES:-10}"
MAX_ACCOUNT_SWITCHES="${CODEX_AUTONOMOUS_MAX_SWITCHES:-10}"
HOOKS_ACTIVE=false
RESPONSE_SCHEMA_FILE=""
RUN_TRANSCRIPT=""
RUN_LAST_MESSAGE_FILE=""
LAST_ACTION=""
LAST_MESSAGE=""
LAST_QUESTION=""

DEFAULT_CODEX_FLAGS="${CODEX_AUTONOMOUS_FLAGS:-}"
RESPONSE_REMINDER="Respond only in JSON with action (continue|needs_user|complete), message, question (question can be empty)."

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

has_cmd() { command -v "$1" >/dev/null 2>&1; }

log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_ok() { echo -e "${GREEN}[OK]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_err() { echo -e "${RED}[ERROR]${NC} $*"; }

die() { log_err "$*"; exit 1; }

apply_epic_continue_default() {
  local epic="$1"
  if [[ -n "$epic" && -z "${CODEX_AUTONOMOUS_CONTINUE_PROMPT:-}" ]]; then
    CODEX_AUTONOMOUS_CONTINUE_PROMPT="Continue autonomously on Epic #${epic}. Do not run session-start/work-intake and do not open AGENTS.md/SKILL.md. Pick the next Ready child issue and proceed. If blocked, document it and move on."
  fi
}

epic_fast_start_enabled() {
  case "${CODEX_AUTONOMOUS_EPIC_FAST_START:-true}" in
    0|false|no) return 1 ;;
  esac
  return 0
}

apply_epic_interactive_default() {
  local epic="$1"
  if [[ -n "$epic" && -z "${CODEX_AUTONOMOUS_INTERACTIVE:-}" ]]; then
    CODEX_AUTONOMOUS_INTERACTIVE="false"
    log_info "Epic mode: disabling interactive prompts (set CODEX_AUTONOMOUS_INTERACTIVE=true to override)."
  fi
  apply_epic_continue_default "$epic"
}

check_tool() {
  local cmd="$1"
  local hint="$2"
  if ! has_cmd "$cmd"; then
    die "$cmd is required but not installed. ${hint}"
  fi
}

get_codex_account_cmd() {
  if [[ -x "${SCRIPT_DIR}/codex-account" ]]; then
    echo "${SCRIPT_DIR}/codex-account"
  elif has_cmd codex-account; then
    echo "codex-account"
  else
    echo ""
  fi
}

hooks_enabled() {
  case "${CODEX_DISABLE_HOOKS:-}" in
    1|true|yes) return 1 ;;
  esac
  return 0
}

prompt_for_reply() {
  local prompt_question="${1:-}"
  local reply=""

  if [[ -t 0 ]]; then
    if [[ -n "$prompt_question" ]]; then
      echo -e "${YELLOW}Codex needs input:${NC} ${prompt_question}"
    fi
    echo -e "${GREEN}Enter a reply, or press Enter to let Codex continue autonomously.${NC}"
    echo "Type :q to exit."
    while IFS= read -r line; do
      if [[ "$line" == ":q" || "$line" == ":quit" ]]; then
        printf '%s' "__CODEX_AUTONOMOUS_QUIT__"
        return 0
      fi
      [[ -z "$line" ]] && break
      if [[ -n "$reply" ]]; then
        reply="${reply}"$'\n'"${line}"
      else
        reply="${line}"
      fi
    done
  else
    if ! read -r -t 0; then
      printf '%s' ""
      return 0
    fi
    reply=$(cat)
  fi

  printf '%s' "$reply"
}

read_new_prompt() {
  local prompt="${CODEX_NEW_PROMPT:-}"

  if [[ -n "$prompt" ]]; then
    printf '%s\n' "$prompt"
    return 0
  fi

  if [[ ! -t 0 ]]; then
    printf '%s\n' ""
    return 0
  fi

  echo -e "${GREEN}Codex is ready for instructions.${NC}"
  while true; do
    if ! read -r -p "Describe the task (Ctrl-D to cancel): " prompt; then
      printf '%s\n' ""
      return 0
    fi
    if [[ -n "$prompt" ]]; then
      printf '%s\n' "$prompt"
      return 0
    fi
    log_warn "No instructions entered. Please describe the task."
  done
}

response_schema_content() {
  cat <<'JSON'
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "CodexAutonomousResponse",
  "type": "object",
  "required": ["action", "message", "question"],
  "properties": {
    "action": { "type": "string", "enum": ["continue", "needs_user", "complete"] },
    "message": { "type": "string" },
    "question": { "type": "string" }
  },
  "additionalProperties": false
}
JSON
}

ensure_response_schema_file() {
  local schema_path="${CODEX_AUTONOMOUS_SCHEMA_FILE:-}"
  if [[ -z "$schema_path" ]]; then
    schema_path="${CODEX_HOME}/schemas/codex-autonomous-response.schema.json"
  fi

  mkdir -p "$(dirname "$schema_path")" 2>/dev/null || true
  local tmp="${schema_path}.tmp.$$"
  response_schema_content > "$tmp"
  if [[ -f "$schema_path" ]] && cmp -s "$tmp" "$schema_path"; then
    rm -f "$tmp"
  else
    mv "$tmp" "$schema_path"
  fi

  RESPONSE_SCHEMA_FILE="$schema_path"
}

last_agent_message_from_transcript() {
  local transcript="$1"
  [[ -f "$transcript" ]] || return 1
  jq -r 'select(.type=="item.completed" and .item.type=="agent_message") | .item.text' "$transcript" | tail -n 1
}

normalize_response_json() {
  local raw="$1"
  [[ -n "$raw" ]] || return 1

  if echo "$raw" | jq -e 'type=="object"' >/dev/null 2>&1; then
    echo "$raw"
    return 0
  fi

  if echo "$raw" | jq -e 'type=="string"' >/dev/null 2>&1; then
    local parsed
    parsed=$(echo "$raw" | jq -r 'fromjson? // empty')
    if [[ -n "$parsed" ]] && echo "$parsed" | jq -e 'type=="object"' >/dev/null 2>&1; then
      echo "$parsed"
      return 0
    fi
  fi

  return 1
}

get_last_response_json() {
  local raw=""
  if [[ -n "$RUN_LAST_MESSAGE_FILE" && -s "$RUN_LAST_MESSAGE_FILE" ]]; then
    raw=$(cat "$RUN_LAST_MESSAGE_FILE")
    rm -f "$RUN_LAST_MESSAGE_FILE" 2>/dev/null || true
    RUN_LAST_MESSAGE_FILE=""
  fi

  if [[ -z "$raw" && -n "$RUN_TRANSCRIPT" ]]; then
    raw=$(last_agent_message_from_transcript "$RUN_TRANSCRIPT" 2>/dev/null || true)
  fi

  [[ -n "$raw" ]] || return 1
  normalize_response_json "$raw"
}

parse_response_action() {
  local json="$1"
  LAST_ACTION=$(echo "$json" | jq -r '.action // empty')
  LAST_ACTION=$(echo "$LAST_ACTION" | tr '[:upper:]' '[:lower:]')
  LAST_MESSAGE=$(echo "$json" | jq -r '.message // empty')
  LAST_QUESTION=$(echo "$json" | jq -r '.question // empty')

  if [[ -z "$LAST_MESSAGE" ]]; then
    LAST_MESSAGE="$LAST_QUESTION"
  fi

  case "$LAST_ACTION" in
    ask|question|needs_input|need_input) LAST_ACTION="needs_user" ;;
    ack|acknowledge|continue|next|proceed) LAST_ACTION="continue" ;;
    done|completed|finished) LAST_ACTION="complete" ;;
  esac

  if [[ -z "$LAST_MESSAGE" ]]; then
    return 1
  fi

  if [[ "$LAST_ACTION" == "needs_user" && -z "$LAST_QUESTION" ]]; then
    return 1
  fi

  case "$LAST_ACTION" in
    continue|needs_user|complete) return 0 ;;
  esac
  return 1
}

command_is_inspection() {
  local cmd="$1"
  [[ -n "$cmd" ]] || return 1
  echo "$cmd" | grep -Eqi '(^|[[:space:]/"'"'"'`])(rg|grep|cat|sed|awk|head|tail|find|fd|tree|stat)([[:space:]]|$)|git[[:space:]]+(show|grep|diff)'
}

last_turn_has_inspection() {
  local transcript="$1"
  [[ -f "$transcript" ]] || return 1

  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    if ! echo "$line" | jq -e . >/dev/null 2>&1; then
      continue
    fi

    local event_type
    event_type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null || true)
    if [[ "$event_type" == "turn.started" ]]; then
      return 1
    fi

    if [[ "$event_type" == "item.started" || "$event_type" == "item.completed" ]]; then
      local item_type
      item_type=$(echo "$line" | jq -r '.item.type // empty' 2>/dev/null || true)
      case "$item_type" in
        command_execution)
          local cmd
          cmd=$(echo "$line" | jq -r '.item.command // empty' 2>/dev/null || true)
          if command_is_inspection "$cmd"; then
            return 0
          fi
          ;;
        mcp_tool_call)
          return 0
          ;;
      esac
    fi
  done < <(tac "$transcript")

  return 1
}

question_has_evidence() {
  local text="$1"
  [[ -n "$text" ]] || return 1

  if echo "$text" | grep -Eq '([A-Za-z0-9._/-]+\\.(md|ts|tsx|js|jsx|json|yml|yaml|toml|sh|py|go|rs|rb|java|kt|swift|c|cpp|h|hpp))'; then
    return 0
  fi

  if echo "$text" | grep -Eiq '(README|FEATURES|BRANDING|AGENTS)\\.md|docs/|storybook'; then
    return 0
  fi

  if echo "$text" | grep -Eiq '(after (checking|reviewing|reading|searching)|i (checked|reviewed|searched|looked)|could not find|couldn'"'"'t find|not found|no mention)'; then
    return 0
  fi

  return 1
}

should_prompt_user() {
  local transcript="$1"
  local question="$2"

  if ! last_turn_has_inspection "$transcript"; then
    return 1
  fi

  if question_has_evidence "$question"; then
    return 0
  fi

  return 1
}

question_gate_message() {
  local reason="$1"
  cat <<EOF
Do not ask the user yet. ${reason}
Inspect the repository and docs first (use rg/cat) and answer if possible. Only ask if the answer is still missing after search, and cite file evidence or explicitly state what could not be found.
EOF
}

wrap_resume_prompt() {
  local base="${1:-}"

  if [[ -n "$base" && "$base" == *"$RESPONSE_REMINDER"* ]]; then
    printf '%s' "$base"
    return 0
  fi

  if [[ -z "$base" ]]; then
    printf '%s' "$RESPONSE_REMINDER"
    return 0
  fi

  printf '%s\n\n%s' "$base" "$RESPONSE_REMINDER"
}

resolve_hook_runner() {
  if [[ -n "${CODEX_HOOK_RUNNER:-}" && -x "${CODEX_HOOK_RUNNER}" ]]; then
    echo "${CODEX_HOOK_RUNNER}"
  elif [[ -x "${SCRIPT_DIR}/codex-hook-runner" ]]; then
    echo "${SCRIPT_DIR}/codex-hook-runner"
  elif has_cmd codex-hook-runner; then
    echo "codex-hook-runner"
  else
    echo ""
  fi
}

hook_block_file_for_session() {
  local session_id="$1"
  local codex_home="${CODEX_HOME:-${HOME}/.codex}"
  echo "${codex_home}/.hook-block.${session_id}"
}

handle_hook_account_state() {
  local session_id="$1"
  local codex_home="${CODEX_HOME:-${HOME}/.codex}"
  local suffix=".${session_id}"
  local switch_file="${codex_home}/.pending-account-switch${suffix}"
  local sleep_file="${codex_home}/.account-sleep-mode${suffix}"

  if [[ -f "$switch_file" ]]; then
    local next_account
    next_account=$(jq -r '.to // empty' "$switch_file" 2>/dev/null || echo "")
    rm -f "$switch_file" 2>/dev/null || true
    if [[ -n "$next_account" ]]; then
      echo "Account switched to ${next_account}. Resume work without repeating the failed request."
    else
      echo "Account switched. Resume work without repeating the failed request."
    fi
    return 0
  fi

  if [[ -f "$sleep_file" ]]; then
    local cooldown
    cooldown=$(jq -r '.cooldown_minutes // empty' "$sleep_file" 2>/dev/null || echo "")
    rm -f "$sleep_file" 2>/dev/null || true
    if [[ -n "$cooldown" ]]; then
      CODEX_ACCOUNT_COOLDOWN_MINUTES="$cooldown"
    fi
    wait_for_account_cooldown
    echo "All accounts were exhausted. Cooldown complete; resume work carefully."
    return 0
  fi

  return 1
}

ensure_session_log() {
  mkdir -p "$(dirname "$SESSION_LOG")" 2>/dev/null || true
  touch "$SESSION_LOG" 2>/dev/null || true
  chmod 600 "$SESSION_LOG" 2>/dev/null || true
}

uuid() {
  uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "$(date +%s)-${RANDOM}-${RANDOM}"
}

count_lines() {
  local f="$1"
  if [[ -f "$f" ]]; then
    wc -l < "$f" | tr -d ' '
  else
    echo "0"
  fi
}

discover_new_session_id() {
  local before_lines="$1"
  local after_lines
  after_lines=$(count_lines "$HISTORY_FILE")
  if [[ "$after_lines" -le "$before_lines" ]]; then
    echo ""
    return 1
  fi
  # Take the first new history line appended after before_lines
  local line
  line=$(sed -n "$((before_lines + 1))p" "$HISTORY_FILE" 2>/dev/null || true)
  [[ -z "$line" ]] && { echo ""; return 1; }
  echo "$line" | jq -r '.session_id // empty' 2>/dev/null || echo ""
}

find_session_file() {
  local session_id="$1"
  [[ -z "$session_id" ]] && return 1
  [[ -d "$SESSIONS_DIR" ]] || return 1
  # Codex stores sessions under YYYY/MM/DD/*.jsonl with the session UUID in the filename.
  find "$SESSIONS_DIR" -type f -name "*${session_id}.jsonl" 2>/dev/null | head -n 1
}

detect_plan_limit_in_transcript() {
  local transcript="$1"
  [[ -f "$transcript" ]] || return 1

  local patterns=(
    "rate.?limit"
    "quota"
    "too.?many.?requests"
    "429"
    "capacity"
    "try.?again.?later"
    "insufficient_quota"
    "billing"
    "plan.?limit"
  )

  local combined=""
  local p
  for p in "${patterns[@]}"; do
    [[ -n "$combined" ]] && combined="${combined}|"
    combined="${combined}${p}"
  done

  tail -200 "$transcript" 2>/dev/null | grep -qiE "$combined"
}

try_switch_account() {
  local cmd
  cmd=$(get_codex_account_cmd)
  [[ -n "$cmd" ]] || return 1

  if ! next=$("$cmd" next 2>/dev/null); then
    return 2
  fi

  "$cmd" mark-exhausted >/dev/null 2>&1 || true
  "$cmd" switch "$next" >/dev/null 2>&1 || return 1
  echo "$next"
  return 0
}

wait_for_account_cooldown() {
  local cooldown_minutes="${CODEX_ACCOUNT_COOLDOWN_MINUTES:-5}"
  local seconds=$((cooldown_minutes * 60))
  log_warn "All accounts exhausted. Waiting ${cooldown_minutes} minutes for cooldown..."

  while [[ $seconds -gt 0 ]]; do
    local mins=$((seconds / 60))
    local secs=$((seconds % 60))
    printf "\r${BLUE}Resuming in: %02d:%02d${NC}  " "$mins" "$secs"
    sleep 1
    ((seconds--))
  done
  echo ""

  local cmd
  cmd=$(get_codex_account_cmd)
  if [[ -n "$cmd" ]]; then
    "$cmd" reset-exhausted >/dev/null 2>&1 || true
  fi
}

get_session_info_by_id() {
  local id="$1"
  [[ -f "$SESSION_LOG" ]] || return 1
  grep " ${id} " "$SESSION_LOG" | tail -n 1
}

get_latest_session_line() {
  [[ -f "$SESSION_LOG" ]] || return 1
  tail -n 1 "$SESSION_LOG"
}

list_sessions() {
  ensure_session_log
  echo -e "${CYAN}Autonomous Session History:${NC}"
  echo ""
  if [[ ! -s "$SESSION_LOG" ]]; then
    echo "  No sessions recorded yet."
    return 0
  fi

  echo -e "  ${BLUE}WORKTREE ID                          CODEX SESSION                        REPO           STATUS${NC}"
  echo -e "  ─────────────────────────────────────────────────────────────────────────────────────────────────────"

  tail -20 "$SESSION_LOG" | tac | while read -r line; do
    [[ -z "$line" ]] && continue
    local worktree_id codex_sid repo details
    worktree_id=$(echo "$line" | awk '{print $2}')
    codex_sid=$(echo "$line" | awk '{print $3}')
    repo=$(echo "$line" | awk '{print $4}')

    local status="${RED}no session${NC}"
    local sf
    sf=$(find_session_file "$codex_sid" || true)
    [[ -n "$sf" ]] && status="${GREEN}resumable${NC}"

    printf "  %-36s %-36s %-14s %s\n" "$worktree_id" "$codex_sid" "$repo" "$status"
  done

  echo ""
  echo -e "${YELLOW}To resume:${NC}"
  echo -e "  Most recent:  ${CYAN}codex-autonomous --continue${NC}"
  echo -e "  By worktree:  ${CYAN}codex-autonomous --resume <worktree-id>${NC}"
  echo -e "  By session:   ${CYAN}codex-autonomous --resume <codex-session-uuid>${NC}"
}

parse_default_branch() {
  local b
  b=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | tr -d ' ' || true)
  if [[ -n "$b" ]]; then
    echo "$b"
    return 0
  fi
  if git rev-parse --verify origin/main >/dev/null 2>&1; then
    echo "main"
    return 0
  fi
  if git rev-parse --verify origin/master >/dev/null 2>&1; then
    echo "master"
    return 0
  fi
  echo "main"
}

ensure_github_token() {
  if [[ -z "${GITHUB_PERSONAL_ACCESS_TOKEN:-}" ]]; then
    log_warn "GITHUB_PERSONAL_ACCESS_TOKEN not set, fetching from gh CLI..."
    local token
    token=$(gh auth token 2>/dev/null || true)
    [[ -n "$token" ]] || die "Could not fetch GitHub token from gh. Run: gh auth login"
    export GITHUB_PERSONAL_ACCESS_TOKEN="$token"
    log_ok "GITHUB_PERSONAL_ACCESS_TOKEN set from gh auth token"
  fi

  if [[ -z "${GITHUB_TOKEN:-}" ]]; then
    export GITHUB_TOKEN="$GITHUB_PERSONAL_ACCESS_TOKEN"
  fi
}

run_codex_session() {
  local mode="$1"               # new|resume
  local worktree_dir="$2"
  local prompt="${3:-}"
  local codex_session_id="${4:-}"
  local before_lines="$5"

  if [[ "$mode" == "resume" ]]; then
    prompt=$(wrap_resume_prompt "$prompt")
  fi

  local -a flags=()
  # shellcheck disable=SC2206
  flags=(${DEFAULT_CODEX_FLAGS})
  local has_dangerous=false
  local flag
  for flag in "${flags[@]}"; do
    if [[ "$flag" == "--dangerously-bypass-approvals-and-sandbox" ]]; then
      has_dangerous=true
      break
    fi
  done
  if [[ "$has_dangerous" == "false" ]]; then
    flags+=("--dangerously-bypass-approvals-and-sandbox")
  fi

  if [[ "$mode" == "new" ]]; then
    local has_output_schema=false
    local has_output_last_message=false
    for flag in "${flags[@]}"; do
      case "$flag" in
        --output-schema)
          has_output_schema=true
          ;;
        --output-last-message|-o)
          has_output_last_message=true
          ;;
      esac
    done

    if [[ "$has_output_schema" == "false" ]]; then
      ensure_response_schema_file
      response_schema="$RESPONSE_SCHEMA_FILE"
      if [[ -n "$response_schema" ]]; then
        flags+=("--output-schema" "$response_schema")
      fi
    fi

    if [[ "$has_output_last_message" == "false" ]]; then
      local lm_dir="${CODEX_HOME}/logs"
      mkdir -p "$lm_dir" 2>/dev/null || true
      last_message_file=$(mktemp "${lm_dir}/autonomous-last-message.${CODEX_AUTONOMOUS_SESSION_ID:-session}.XXXXXX.json")
      flags+=("--output-last-message" "$last_message_file")
    fi
  fi
  local exit_code=0
  local use_hooks=false
  local hook_runner=""
  local hook_transcript=""
  local hook_root=""
  local hook_config=""
  local response_schema=""
  local last_message_file=""
  HOOKS_ACTIVE=false

  hook_runner=$(resolve_hook_runner)
  if hooks_enabled; then
    export CODEX_HOOKS=1
    if [[ -n "$hook_runner" ]]; then
      hook_root="${CODEX_HOOK_ROOT:-${CODEX_HOME}/hooks}"
      hook_config="${CODEX_HOOK_CONFIG:-${hook_root}/hooks.json}"
      if [[ -f "$hook_config" ]]; then
        use_hooks=true
        HOOKS_ACTIVE=true
        hook_transcript="${CODEX_HOOK_TRANSCRIPT:-${CODEX_HOME}/logs/hook-${CODEX_AUTONOMOUS_SESSION_ID:-session}.jsonl}"
        mkdir -p "$(dirname "$hook_transcript")" 2>/dev/null || true
        export CODEX_HOOK_ROOT="$hook_root"
        export CODEX_HOOK_CONFIG="$hook_config"
        export CODEX_PROJECT_ROOT="$worktree_dir"
        CODEX_HOOK_BLOCK_FILE="$(hook_block_file_for_session "${CODEX_AUTONOMOUS_SESSION_ID:-session}")"
        export CODEX_HOOK_BLOCK_FILE
        rm -f "$CODEX_HOOK_BLOCK_FILE" 2>/dev/null || true
      else
        log_warn "hooks.json not found at ${hook_config}; running without hooks"
        export CODEX_HOOKS=0
        hook_transcript="${CODEX_HOOK_TRANSCRIPT:-${CODEX_HOME}/logs/hook-${CODEX_AUTONOMOUS_SESSION_ID:-session}.jsonl}"
        mkdir -p "$(dirname "$hook_transcript")" 2>/dev/null || true
        hook_config="$(mktemp "${CODEX_HOME}/hooks.empty.XXXXXX")"
        printf '%s\n' '{"hooks":{}}' > "$hook_config"
        use_hooks=true
        HOOKS_ACTIVE=false
        export CODEX_HOOK_ROOT="$hook_root"
        export CODEX_HOOK_CONFIG="$hook_config"
        export CODEX_PROJECT_ROOT="$worktree_dir"
        CODEX_HOOK_BLOCK_FILE="$(hook_block_file_for_session "${CODEX_AUTONOMOUS_SESSION_ID:-session}")"
        export CODEX_HOOK_BLOCK_FILE
        rm -f "$CODEX_HOOK_BLOCK_FILE" 2>/dev/null || true
      fi
    else
      log_warn "Hooks enabled but codex-hook-runner not found; running without hooks"
    fi
  else
    export CODEX_HOOKS=0
    if [[ -n "$hook_runner" ]]; then
      hook_root="${CODEX_HOOK_ROOT:-${CODEX_HOME}/hooks}"
      hook_transcript="${CODEX_HOOK_TRANSCRIPT:-${CODEX_HOME}/logs/hook-${CODEX_AUTONOMOUS_SESSION_ID:-session}.jsonl}"
      mkdir -p "$(dirname "$hook_transcript")" 2>/dev/null || true
      hook_config="$(mktemp "${CODEX_HOME}/hooks.empty.XXXXXX")"
      printf '%s\n' '{"hooks":{}}' > "$hook_config"
      use_hooks=true
      HOOKS_ACTIVE=false
      export CODEX_HOOK_ROOT="$hook_root"
      export CODEX_HOOK_CONFIG="$hook_config"
      export CODEX_PROJECT_ROOT="$worktree_dir"
      CODEX_HOOK_BLOCK_FILE="$(hook_block_file_for_session "${CODEX_AUTONOMOUS_SESSION_ID:-session}")"
      export CODEX_HOOK_BLOCK_FILE
      rm -f "$CODEX_HOOK_BLOCK_FILE" 2>/dev/null || true
    fi
  fi

  if [[ "$use_hooks" == "true" ]]; then
    if [[ "$mode" == "new" ]]; then
      "$hook_runner" --project-root "$worktree_dir" --hook-root "$hook_root" --hooks "$hook_config" --transcript "$hook_transcript" \
        exec "${flags[@]}" -C "$worktree_dir" "$prompt" || exit_code=$?
    else
      (cd "$worktree_dir" && "$hook_runner" --project-root "$worktree_dir" --hook-root "$hook_root" --hooks "$hook_config" --transcript "$hook_transcript" \
        exec "${flags[@]}" resume "$codex_session_id" "$prompt") || exit_code=$?
    fi
  else
    if [[ "$mode" == "new" ]]; then
      codex exec "${flags[@]}" -C "$worktree_dir" "$prompt" || exit_code=$?
    else
      (cd "$worktree_dir" && codex exec "${flags[@]}" resume "$codex_session_id" "$prompt") || exit_code=$?
    fi
  fi

  RUN_DISCOVERED=""
  if [[ -z "$codex_session_id" ]]; then
    RUN_DISCOVERED=$(discover_new_session_id "$before_lines" || true)
  fi
  if [[ -z "$RUN_DISCOVERED" && -f "/tmp/codex-session-marker" ]]; then
    RUN_DISCOVERED=$(cat "/tmp/codex-session-marker" 2>/dev/null || true)
  fi
  if [[ -n "${hook_config:-}" && -f "$hook_config" && "$hook_config" == *"/hooks.empty."* ]]; then
    rm -f "$hook_config" 2>/dev/null || true
  fi
  RUN_TRANSCRIPT="$hook_transcript"
  RUN_LAST_MESSAGE_FILE="$last_message_file"
  RUN_EXIT_CODE="$exit_code"
}

# Ignore signals in parent so Codex gets them; restart loop handles exits.
trap '' SIGTERM SIGINT

REPO_PATH=""
EPIC=""
NEW_MODE=false
CONTINUE_MODE=false
RESUME_ID=""
LIST_MODE=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -e|--epic)
      [[ -n "${2:-}" && "${2:-}" != -* ]] || die "--epic requires a value"
      EPIC="$2"
      shift 2
      ;;
    -n|--new)
      NEW_MODE=true
      shift
      ;;
    -c|--continue)
      CONTINUE_MODE=true
      shift
      ;;
    --resume)
      if [[ -n "${2:-}" && "${2:-}" != -* ]]; then
        RESUME_ID="$2"
        shift 2
      else
        RESUME_ID="INTERACTIVE"
        shift
      fi
      ;;
    -l|--list)
      LIST_MODE=true
      shift
      ;;
    -r|--repo)
      [[ -n "${2:-}" && "${2:-}" != -* ]] || die "--repo requires a path"
      REPO_PATH="$2"
      shift 2
      ;;
    -v|--version)
      echo "codex-autonomous version ${VERSION}"
      exit 0
      ;;
    -h|--help)
      head -n 40 "$0" | grep -E "^#" | sed 's/^# *//'
      exit 0
      ;;
    *)
      die "Unknown option: $1 (use --help)"
      ;;
  esac
done

EPIC="${EPIC:-${WORK_EPIC:-}}"
apply_epic_interactive_default "$EPIC"

check_tool "git" "Install git via your package manager"
check_tool "gh" "Install GitHub CLI: https://cli.github.com/"
check_tool "jq" "Install jq via your package manager"
check_tool "codex" "Install Codex CLI: pnpm add -g @openai/codex"

if [[ "$LIST_MODE" == "true" ]]; then
  list_sessions
  exit 0
fi

ensure_session_log

# Handle --continue / --resume
if [[ "$CONTINUE_MODE" == "true" || -n "$RESUME_ID" ]]; then
  if [[ "$CONTINUE_MODE" == "true" ]]; then
    line=$(get_latest_session_line || true)
    [[ -n "$line" ]] || die "No recorded sessions. Start one with: codex-autonomous"
  else
    if [[ "$RESUME_ID" == "INTERACTIVE" ]]; then
      list_sessions
      echo ""
      read -r -p "Enter worktree id or codex session id to resume: " picked
      [[ -n "$picked" ]] || die "No selection"
      RESUME_ID="$picked"
    fi

    line=$(get_session_info_by_id "$RESUME_ID" || true)
    if [[ -z "$line" ]]; then
      # Try lookup by Codex session id (3rd field)
      line=$(awk -v sid="$RESUME_ID" '$3==sid {print}' "$SESSION_LOG" | tail -n 1 || true)
    fi
    [[ -n "$line" ]] || die "Session not found in $SESSION_LOG: $RESUME_ID"
  fi

  WORKTREE_ID=$(echo "$line" | awk '{print $2}')
  CODEX_SESSION_ID=$(echo "$line" | awk '{print $3}')
  REPO_NAME=$(echo "$line" | awk '{print $4}')
  WORKTREE_DIR=$(echo "$line" | awk '{print $5}')
  DETAILS=$(echo "$line" | awk '{print $6}')
  if [[ "$DETAILS" == epic=#* ]]; then
    RESUME_EPIC="${DETAILS#epic=#}"
    apply_epic_interactive_default "$RESUME_EPIC"
  fi
  export CODEX_AUTONOMOUS_SESSION_ID="${WORKTREE_ID}"

  log_info "Resuming worktree ${WORKTREE_ID} (Codex session: ${CODEX_SESSION_ID})"

  if [[ ! -d "$WORKTREE_DIR" ]]; then
    log_warn "Worktree missing. Recreating at: $WORKTREE_DIR"
    REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || true)
    [[ -n "$REPO_ROOT" ]] || die "Run resume from within a git repo to recreate the worktree"
    DEFAULT_BRANCH=$(parse_default_branch)
    mkdir -p "$(dirname "$WORKTREE_DIR")"
    git worktree prune >/dev/null 2>&1 || true
    git fetch origin "$DEFAULT_BRANCH" >/dev/null 2>&1 || true
    git worktree add "$WORKTREE_DIR" "origin/${DEFAULT_BRANCH}" >/dev/null
  fi

  cd "$WORKTREE_DIR"
  ensure_github_token

  CRASHES=0
  ACCOUNT_SWITCHES=0
  MSG=""
  while true; do
    before_lines=$(count_lines "$HISTORY_FILE")
    result=$(run_codex_session "resume" "$WORKTREE_DIR" "$MSG" "$CODEX_SESSION_ID" "$before_lines")
    EXIT_CODE="${result%%|*}"

    if [[ "$EXIT_CODE" -eq 0 ]]; then
      if response_json=$(get_last_response_json); then
        if parse_response_action "$response_json"; then
          case "$LAST_ACTION" in
            complete)
              log_ok "Session completed successfully"
              exit 0
              ;;
            continue)
              MSG="${CODEX_AUTONOMOUS_CONTINUE_PROMPT:-Continue autonomously.}"
              continue
              ;;
            needs_user)
              if [[ "${CODEX_AUTONOMOUS_INTERACTIVE:-true}" == "false" ]]; then
                log_warn "Codex requested input; continuing autonomously (CODEX_AUTONOMOUS_INTERACTIVE=false)."
                MSG="${CODEX_AUTONOMOUS_CONTINUE_PROMPT:-Continue autonomously.}"
                continue
              fi
              if ! last_turn_has_inspection "$RUN_TRANSCRIPT"; then
                MSG=$(question_gate_message "Your last turn asked a question without inspecting the repository.")
                continue
              fi
              if ! question_has_evidence "$LAST_QUESTION"; then
                MSG=$(question_gate_message "Your question did not cite file evidence or state what was missing after search.")
                continue
              fi
              MSG=$(prompt_for_reply "$LAST_QUESTION")
              if [[ "$MSG" == "__CODEX_AUTONOMOUS_QUIT__" ]]; then
                exit 0
              fi
              if [[ -z "$MSG" ]]; then
                MSG="${CODEX_AUTONOMOUS_CONTINUE_PROMPT:-Continue autonomously.}"
              fi
              continue
              ;;
          esac
        fi
      fi

      log_warn "Codex response missing structured action; enforcing response contract."
      MSG=$(question_gate_message "Your response was not valid JSON in the required format.")
      continue
    fi

    if [[ "${HOOKS_ACTIVE}" == "true" && "$EXIT_CODE" -eq 2 ]]; then
      if [[ -f "${CODEX_HOOK_BLOCK_FILE:-}" ]]; then
        MSG=$(cat "$CODEX_HOOK_BLOCK_FILE" 2>/dev/null || echo "")
        rm -f "$CODEX_HOOK_BLOCK_FILE" 2>/dev/null || true
      fi
      [[ -n "$MSG" ]] || MSG="Hook blocked execution. Address the gate and continue."
      continue
    fi

    if [[ "${HOOKS_ACTIVE}" == "true" ]]; then
      if hook_msg=$(handle_hook_account_state "${CODEX_AUTONOMOUS_SESSION_ID:-$WORKTREE_ID}"); then
        MSG="$hook_msg"
        ACCOUNT_SWITCHES=0
        continue
      fi
    fi

    CRASHES=$((CRASHES + 1))
    log_warn "Codex exited with code ${EXIT_CODE} (crash ${CRASHES}/${MAX_CRASHES})"
    if (( CRASHES >= MAX_CRASHES )); then
      die "Maximum crash limit reached"
    fi

    transcript=$(find_session_file "$CODEX_SESSION_ID" || true)
    if [[ -n "$transcript" ]] && detect_plan_limit_in_transcript "$transcript"; then
      log_warn "Possible plan/rate limit detected"
      switched_to=""
      if switched_to=$(try_switch_account); then
        ACCOUNT_SWITCHES=$((ACCOUNT_SWITCHES + 1))
        if (( ACCOUNT_SWITCHES >= MAX_ACCOUNT_SWITCHES )); then
          die "Maximum account switches (${MAX_ACCOUNT_SWITCHES}) reached"
        fi
        MSG="Account switched to ${switched_to}. Resume work without repeating the failing request."
        log_ok "Switched account → ${switched_to}"
        continue
      elif [[ "$?" -eq 2 ]]; then
        wait_for_account_cooldown
        MSG="All accounts were exhausted. Cooldown complete; resume work carefully."
        ACCOUNT_SWITCHES=0
        continue
      fi
    fi

    MSG="You exited unexpectedly (code ${EXIT_CODE}). Diagnose the failure and continue. Do NOT repeat the same action if it caused a crash."
    sleep 2
  done
fi

# If repo path provided, cd into it
if [[ -n "$REPO_PATH" ]]; then
  cd "$REPO_PATH"
fi

# Validate repo
git rev-parse --show-toplevel >/dev/null 2>&1 || die "Not in a git repository (use --repo <path>)"
gh auth status >/dev/null 2>&1 || die "GitHub CLI not authenticated. Run: gh auth login"

ensure_github_token

# Validate epic (if specified)
ISSUE_TITLE=""
if [[ -n "$EPIC" ]]; then
  log_info "Validating Epic #${EPIC}..."
  ISSUE_JSON=$(gh issue view "$EPIC" --json state,title,url 2>/dev/null) || die "Epic #${EPIC} not found"
  ISSUE_STATE=$(echo "$ISSUE_JSON" | jq -r '.state')
  ISSUE_TITLE=$(echo "$ISSUE_JSON" | jq -r '.title')
  ISSUE_URL=$(echo "$ISSUE_JSON" | jq -r '.url')
  [[ "$ISSUE_STATE" == "OPEN" ]] || die "Epic #${EPIC} is ${ISSUE_STATE} (${ISSUE_URL})"
  log_ok "Epic validated: ${ISSUE_TITLE}"
fi

REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "$REPO_ROOT")
DEFAULT_BRANCH=$(parse_default_branch)

WORKTREE_ID=$(uuid)
WORKTREE_DIR="${WORKTREE_ROOT}/${REPO_NAME}/${WORKTREE_ID}"
export CODEX_AUTONOMOUS_SESSION_ID="${WORKTREE_ID}"

git worktree prune >/dev/null 2>&1 || true
mkdir -p "$WORKTREE_ROOT"
chmod 700 "$WORKTREE_ROOT" 2>/dev/null || true

log_info "Creating worktree at ${WORKTREE_DIR} from origin/${DEFAULT_BRANCH}..."
mkdir -p "$(dirname "$WORKTREE_DIR")"
git fetch origin "$DEFAULT_BRANCH" >/dev/null 2>&1 || true
git worktree add "$WORKTREE_DIR" "origin/${DEFAULT_BRANCH}" >/dev/null

details="scope=all"
if [[ -n "$EPIC" ]]; then
  details="epic=#${EPIC}"
fi

CODEX_SESSION_ID=""
before_lines=$(count_lines "$HISTORY_FILE")

echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
echo -e "${CYAN}║${NC}           ${GREEN}Codex Autonomous Issue-Driven Development${NC}           ${CYAN}║${NC}"
echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
echo ""
echo -e "${BLUE}Worktree ID:${NC}  ${WORKTREE_ID}"
echo -e "${BLUE}Repository:${NC}   ${REPO_NAME}"
echo -e "${BLUE}Branch:${NC}       ${DEFAULT_BRANCH}"
echo -e "${BLUE}Worktree:${NC}     ${WORKTREE_DIR}"
if [[ -n "$EPIC" ]]; then
  echo -e "${BLUE}Focus Epic:${NC}   #${EPIC} - ${ISSUE_TITLE}"
fi
echo ""

cd "$WORKTREE_DIR"

USER_PROMPT=""
if [[ "$NEW_MODE" == "true" ]]; then
  USER_PROMPT=$(read_new_prompt)
  if [[ -z "$USER_PROMPT" ]]; then
    die "No instructions provided. Re-run with --new and enter a task or set CODEX_NEW_PROMPT."
  fi
fi

RESPONSE_CONTRACT=$(cat <<'EOF'
RESPONSE CONTRACT (MANDATORY):
Return a single JSON object with:
- action: "continue" | "needs_user" | "complete"
- message: user-facing status or answer
- question: include always (empty string when not needed)

Rules:
- Do not ask questions that can be answered by reading the repo or docs. Search first.
- Do not include markdown fences or extra text outside the JSON object.
EOF
)

if [[ "$NEW_MODE" == "true" ]]; then
  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

This worktree was created from origin/${DEFAULT_BRANCH} to allow autonomous work without affecting the main repository.

ENVIRONMENT:
- Isolated worktree from origin/${DEFAULT_BRANCH}
- GitHub token configured for API access
- Run tests/builds locally before PRs

USER REQUEST:
${USER_PROMPT}

${RESPONSE_CONTRACT}"
else
  TASK_INSTRUCTION="TASK: Use an issue-driven development workflow and work autonomously until all assigned work is complete."
  if [[ -n "$EPIC" && epic_fast_start_enabled ]]; then
    TASK_INSTRUCTION=$(cat <<EOF
FAST START (Epic mode):
- Do NOT run session-start/work-intake and do NOT open AGENTS.md or any SKILL.md files.
- Immediately fetch Epic #${EPIC} and its child issues (from the epic body) via gh.
- Check child issue Status in the project board and pick the next Ready issue.
- Start implementation (create branch, update Status → In Progress, make changes, run tests, open PR, update Status → In Review).
EOF
)
  fi
  if [[ -n "$EPIC" ]]; then
    EPIC_INSTRUCTION="Focus exclusively on Epic #${EPIC} and its child issues. Do not work on unrelated issues. Avoid broad repo/skill scans; read the epic and immediate child issues, then start implementation."
    if epic_fast_start_enabled; then
      EPIC_INSTRUCTION="${EPIC_INSTRUCTION} Fast start: skip session-start/work-intake and avoid reading AGENTS.md or SKILL.md unless explicitly requested. Immediately fetch the epic + child issues via gh, pick the next Ready child issue, and begin implementation."
    fi
  else
    EPIC_INSTRUCTION="Work through all open epics and issues in priority order."
  fi

  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

${TASK_INSTRUCTION}

IMPORTANT:
- Create feature branches and push to origin
- Open PRs when work is complete (do not merge directly to ${DEFAULT_BRANCH})
- Verify locally (tests/build) before creating PRs

${EPIC_INSTRUCTION}

${RESPONSE_CONTRACT}"
fi

cleanup() {
  local exit_code="$1"
  if [[ "$exit_code" -eq 0 ]]; then
    log_info "Cleaning up worktree..."
    cd "$REPO_ROOT" 2>/dev/null || true
    git worktree remove --force "$WORKTREE_DIR" >/dev/null 2>&1 || true
    git worktree prune >/dev/null 2>&1 || true
    log_ok "Session ended: ${WORKTREE_ID}"
  else
    log_warn "Session exited with code ${exit_code}. Preserving worktree for recovery."
    echo -e "${BLUE}Worktree preserved at:${NC} ${WORKTREE_DIR}"
    echo -e "${BLUE}Resume with:${NC} codex-autonomous --resume ${WORKTREE_ID}"
  fi
}

CRASHES=0
ACCOUNT_SWITCHES=0
MSG=""
FIRST_RUN=true

if [[ "$NEW_MODE" == "true" ]]; then
  log_ok "Starting Codex session..."
else
  log_ok "Starting autonomous operation..."
fi
echo ""

while true; do
  EXIT_CODE=0
  discovered=""

  if [[ "$FIRST_RUN" == "true" ]]; then
    FIRST_RUN=false
    run_codex_session "new" "$WORKTREE_DIR" "$INITIAL_PROMPT" "" "$before_lines"
    EXIT_CODE="${RUN_EXIT_CODE:-0}"
    discovered="${RUN_DISCOVERED:-}"
    CODEX_SESSION_ID="${discovered}"
    [[ -n "$CODEX_SESSION_ID" ]] || CODEX_SESSION_ID=""

    if [[ -n "$CODEX_SESSION_ID" ]]; then
      echo "$(date -Iseconds) ${WORKTREE_ID} ${CODEX_SESSION_ID} ${REPO_NAME} ${WORKTREE_DIR} ${details}" >> "$SESSION_LOG"
      chmod 600 "$SESSION_LOG" 2>/dev/null || true
    else
      log_warn "Could not discover Codex session id; resume will not be available from the log"
    fi
  else
    run_codex_session "resume" "$WORKTREE_DIR" "$MSG" "$CODEX_SESSION_ID" "$(count_lines "$HISTORY_FILE")"
    EXIT_CODE="${RUN_EXIT_CODE:-0}"
  fi

  if [[ "$EXIT_CODE" -eq 0 ]]; then
    if response_json=$(get_last_response_json); then
      if parse_response_action "$response_json"; then
        case "$LAST_ACTION" in
          complete)
            cleanup 0
            exit 0
            ;;
          continue)
            if [[ -z "$CODEX_SESSION_ID" ]]; then
              log_warn "Codex finished but no session id was recorded; ending session."
              cleanup 1
              exit 1
            fi
            MSG="${CODEX_AUTONOMOUS_CONTINUE_PROMPT:-Continue autonomously.}"
            continue
            ;;
          needs_user)
            if [[ -z "$CODEX_SESSION_ID" ]]; then
              log_warn "Codex finished but no session id was recorded; ending session."
              cleanup 1
              exit 1
            fi
            if [[ "${CODEX_AUTONOMOUS_INTERACTIVE:-true}" == "false" ]]; then
              log_warn "Codex requested input; continuing autonomously (CODEX_AUTONOMOUS_INTERACTIVE=false)."
              MSG="${CODEX_AUTONOMOUS_CONTINUE_PROMPT:-Continue autonomously.}"
              continue
            fi
            if ! last_turn_has_inspection "$RUN_TRANSCRIPT"; then
              MSG=$(question_gate_message "Your last turn asked a question without inspecting the repository.")
              continue
            fi
            if ! question_has_evidence "$LAST_QUESTION"; then
              MSG=$(question_gate_message "Your question did not cite file evidence or state what was missing after search.")
              continue
            fi
            MSG=$(prompt_for_reply "$LAST_QUESTION")
            if [[ "$MSG" == "__CODEX_AUTONOMOUS_QUIT__" ]]; then
              cleanup 0
              exit 0
            fi
            if [[ -z "$MSG" ]]; then
              MSG="${CODEX_AUTONOMOUS_CONTINUE_PROMPT:-Continue autonomously.}"
            fi
            continue
            ;;
        esac
      fi
    fi

    log_warn "Codex response missing structured action; enforcing response contract."
    if [[ -z "$CODEX_SESSION_ID" ]]; then
      log_warn "Codex finished but no session id was recorded; ending session."
      cleanup 1
      exit 1
    fi
    MSG=$(question_gate_message "Your response was not valid JSON in the required format.")
    continue
  fi

  if [[ "${HOOKS_ACTIVE}" == "true" && "$EXIT_CODE" -eq 2 ]]; then
    if [[ -f "${CODEX_HOOK_BLOCK_FILE:-}" ]]; then
      MSG=$(cat "$CODEX_HOOK_BLOCK_FILE" 2>/dev/null || echo "")
      rm -f "$CODEX_HOOK_BLOCK_FILE" 2>/dev/null || true
    fi
    [[ -n "$MSG" ]] || MSG="Hook blocked execution. Address the gate and continue."
    continue
  fi

  if [[ "${HOOKS_ACTIVE}" == "true" ]]; then
    if hook_msg=$(handle_hook_account_state "${CODEX_AUTONOMOUS_SESSION_ID:-$WORKTREE_ID}"); then
      MSG="$hook_msg"
      ACCOUNT_SWITCHES=0
      continue
    fi
  fi

CRASHES=$((CRASHES + 1))
log_warn "Codex exited with code ${EXIT_CODE} (crash ${CRASHES}/${MAX_CRASHES})"
if (( CRASHES >= MAX_CRASHES )); then
  cleanup "$EXIT_CODE"
  die "Maximum crash limit reached"
fi

# Account switching on plan/rate limit detection
if [[ -n "$CODEX_SESSION_ID" ]]; then
  transcript=$(find_session_file "$CODEX_SESSION_ID" || true)
  if [[ -n "$transcript" ]] && detect_plan_limit_in_transcript "$transcript"; then
    log_warn "Possible plan/rate limit detected"
    switched_to=""
    if switched_to=$(try_switch_account); then
      ACCOUNT_SWITCHES=$((ACCOUNT_SWITCHES + 1))
      if (( ACCOUNT_SWITCHES >= MAX_ACCOUNT_SWITCHES )); then
        cleanup "$EXIT_CODE"
        die "Maximum account switches (${MAX_ACCOUNT_SWITCHES}) reached"
      fi
      MSG="Account switched to ${switched_to}. Resume work without repeating the failing request."
      log_ok "Switched account → ${switched_to}"
      continue
    elif [[ "$?" -eq 2 ]]; then
      wait_for_account_cooldown
      MSG="All accounts were exhausted. Cooldown complete; resume work carefully."
      ACCOUNT_SWITCHES=0
      continue
    fi
  fi
fi

MSG="You exited unexpectedly (code ${EXIT_CODE}). Diagnose the failure and continue. Do NOT repeat the same action if it caused a crash."
sleep 2
done
